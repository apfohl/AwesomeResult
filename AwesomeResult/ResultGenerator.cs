using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace AwesomeResult
{
    [AttributeUsage(AttributeTargets.Struct)]
    public sealed class GenerateResultAttribute<TError> : Attribute
    {
    }

    [Generator]
    public class ResultGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var resultStructs = context
                .SyntaxProvider
                .CreateSyntaxProvider(IsTarget, GetTarget)
                .Where(syntaxProvider => syntaxProvider is not null)
                .Collect();

            context.RegisterSourceOutput(resultStructs, Execute);
        }

        private static bool IsTarget(SyntaxNode node, CancellationToken _) =>
            node is StructDeclarationSyntax { AttributeLists.Count: > 0 } structDeclarationSyntax
            && structDeclarationSyntax.Modifiers.Any(SyntaxKind.PartialKeyword)
            && structDeclarationSyntax.Modifiers.Any(SyntaxKind.ReadOnlyKeyword);

        private static INamedTypeSymbol GetTarget(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var symbol = context.SemanticModel.GetDeclaredSymbol(context.Node, cancellationToken);

            if (symbol is not INamedTypeSymbol namedTypeSymbol)
            {
                return null;
            }

            var attributeData = namedTypeSymbol
                .GetAttributes()
                .FirstOrDefault(ad =>
                    string.Equals(
                        ad.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                        $"global::{nameof(AwesomeResult)}.GenerateResultAttribute")
                );

            return attributeData is null ? null : namedTypeSymbol;
        }

        private static void Execute(SourceProductionContext context, ImmutableArray<INamedTypeSymbol> symbols)
        {
            foreach (var namedTypeSymbol in symbols.Where(symbol => symbol is not null))
            {
                var source = ProcessStruct(namedTypeSymbol, context);

                if (source is null)
                {
                    continue;
                }

                context.AddSource($"{namedTypeSymbol.ContainingNamespace}_{namedTypeSymbol.Name}.g.cs", source);
            }
        }

        private static string ProcessStruct(INamedTypeSymbol symbol, SourceProductionContext context)
        {
            return GenerateClassSource(symbol, symbol.BaseType?.TypeParameters, symbol.BaseType?.TypeArguments);
        }

        private static string GenerateClassSource(INamedTypeSymbol symbol,
            ImmutableArray<ITypeParameterSymbol>? baseTypeTypeParameters,
            ImmutableArray<ITypeSymbol>? baseTypeTypeArguments)
        {
            StringBuilder source = new(
                $$"""
                  // <auto-generated />

                  namespace {{symbol.ContainingNamespace.ToDisplayString()}}
                  {
                      public partial readonly struct {{symbol.Name}} {
                  """
            );

            source.Append(
                $$"""
                      }
                  }
                  """
            );

            return source.ToString();
        }
    }
}
